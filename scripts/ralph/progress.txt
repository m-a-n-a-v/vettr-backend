# Ralph Progress Log
Started: 2026-02-08
Project: VETTR Backend
---

## Codebase Patterns

### ESM Import Rules
- ALL local imports must use `.js` extension: `import { app } from './app.js'`
- Package imports do NOT use extensions: `import { Hono } from 'hono'`

### Build Command
- `npm run build` ‚Äî TypeScript compilation via tsc
- `npm run dev` ‚Äî Development server via tsx watch
- `npm run test` ‚Äî Run vitest

### Project Root
- `/Users/manav/Space/code/vettr-backend`

### Key Dependencies
- hono: Web framework
- drizzle-orm + @neondatabase/serverless: Database ORM + driver
- @upstash/redis + @upstash/ratelimit: Cache + rate limiting
- zod: Validation
- jsonwebtoken + bcrypt: Auth utilities
- @hono/zod-openapi + @hono/swagger-ui: API documentation

---

## US-001: Initialize project with TypeScript, Hono, and essential dependencies
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Ran npm install successfully (164 packages installed)
- Verified src/index.ts starts Hono server on PORT 3000 via @hono/node-server
- Verified src/app.ts exports configured Hono app with /v1 base path
- npm run build compiles successfully with zero errors
- Tested GET /v1/health endpoint returns proper JSON response
- Files changed: package-lock.json (added)
- **Learnings for future iterations:**
  - Project scaffold was already in place with basic structure
  - Build system works correctly with ESM imports (.js extensions)
  - Health endpoint follows standardized response format with success/data pattern
  - All npm scripts are correctly configured (dev, build, test, typecheck)
  - Basic middleware (logger, cors) already registered on Hono app
---

## US-002: Configure environment variable validation with Zod
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/config/env.ts with Zod schema for environment validation
- Validated PORT, NODE_ENV, DATABASE_URL, JWT_SECRET, UPSTASH vars
- Set appropriate defaults: PORT=3000, NODE_ENV=development, JWT_SECRET has dev default
- Made DATABASE_URL and Upstash Redis vars optional for local development
- Made OAuth credentials (Google, Apple) optional
- Added safeParse with error formatting and process.exit(1) on validation failure
- npm run build passes with zero errors
- Files changed: src/config/env.ts (created)
- **Learnings for future iterations:**
  - Zod's transform() method useful for converting string env vars to numbers
  - Using .optional() allows graceful degradation in development mode
  - safeParse() provides better error messages than parse() for env validation
  - process.exit(1) after validation errors prevents app from starting with bad config
---

## US-003: Set up Drizzle ORM with Neon PostgreSQL connection
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/config/database.ts exporting Drizzle db instance
- Configured Neon serverless driver with Pool and DATABASE_URL from env
- Added graceful error handling with different behaviors for dev vs production
- Database features disabled when DATABASE_URL not set (useful for development)
- Production mode exits if database connection fails (fail-fast principle)
- npm run build passes with zero errors
- Files changed: src/config/database.ts (created)
- **Learnings for future iterations:**
  - Neon's Pool class from @neondatabase/serverless handles connection pooling automatically
  - Drizzle's drizzle() function accepts the pool and returns a typed database client
  - Graceful degradation pattern useful: warn in dev, exit in production
  - Console logging with emoji prefixes (‚úÖ, ‚ö†Ô∏è, ‚ùå, üí•) improves readability
  - Exported db is nullable in type system, services should handle null checks
---

## US-004: Set up Upstash Redis client
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/config/redis.ts with Upstash Redis client initialization
- Used @upstash/redis with REST URL and token from environment variables
- Created src/services/cache.service.ts with comprehensive cache helpers: get, set, del, delMany, exists, ttl
- All helpers include proper error handling and return gracefully when Redis unavailable
- Follows same graceful degradation pattern as database.ts (fail-fast in production, warn in dev)
- npm run build passes with zero errors
- Files changed: src/config/redis.ts (created), src/services/cache.service.ts (created)
- **Learnings for future iterations:**
  - @upstash/redis uses REST API, so no persistent connections needed
  - Cache service returns null/false when Redis unavailable, allowing services to proceed without caching
  - setex() method combines set + expiry in single operation for TTL-based caching
  - Added bonus helpers (delMany, exists, ttl) for future use cases
  - TypeScript generics on get/set allow type-safe caching with proper inference
  - Pattern: all cache operations try/catch with error logging, never throw to caller
---

## US-005: Create standardized API response builder utilities
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/types/api.ts with comprehensive response types (ApiSuccessResponse, ApiErrorResponse, PaginatedResponse)
- Created src/types/pagination.ts with PaginationParams and PaginationMeta types
- Created src/utils/response.ts with success(), error(), and paginated() builder functions
- All responses include meta object with timestamp (ISO 8601) and request_id (UUID v4)
- Created src/types/index.ts barrel export for clean imports
- npm run build passes with zero errors
- Files changed: src/types/api.ts, src/types/pagination.ts, src/types/index.ts, src/utils/response.ts (all created)
- **Learnings for future iterations:**
  - Standardized response format: { success: boolean, data/error: ..., meta: { timestamp, request_id } }
  - Paginated responses nest items and pagination info under data field
  - Error responses have structured error object with code, message, and optional details
  - Using crypto.randomUUID() for Node.js 20+ request ID generation (no external dependency)
  - TypeScript generics on response builders allow type inference for data payloads
  - ResponseMeta interface ensures consistency across all response types
  - snake_case used for all JSON fields (timestamp, request_id, has_more, etc.) per API standards
---
## US-006: Create custom error classes and global error handler
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/utils/errors.ts with comprehensive error class hierarchy
  - AppError base class with statusCode, code, details, isOperational properties
  - Subclasses: AuthRequiredError, AuthExpiredError, AuthInvalidCredentialsError, ForbiddenError, NotFoundError, ValidationError, RateLimitError, TierLimitError, ConflictError, InternalError
  - All error codes defined as TypeScript union type
  - Proper prototype chain setup for instanceof checks
- Created src/middleware/error-handler.ts with global error handler
  - Handles AppError instances with proper status codes
  - Handles Zod validation errors with 422 status
  - Handles generic HTTP errors
  - Hides sensitive error details in production, shows stack traces in development
  - Logs all errors with timestamp for debugging
- Registered error handler on Hono app using app.onError()
- npm run build passes with zero errors
- Files changed: src/utils/errors.ts (created), src/middleware/error-handler.ts (created), src/app.ts (modified)
- **Learnings for future iterations:**
  - Hono's c.json() requires status codes to be cast as `any` to avoid TypeScript errors with ContentfulStatusCode type
  - AppError base class should include isOperational flag to distinguish between operational and programming errors
  - Error.captureStackTrace() maintains proper stack traces in V8 engines
  - Object.setPrototypeOf() required after super() call for proper instanceof behavior with custom error classes
  - Error handler middleware receives (err, c) signature in Hono
  - Environment-based error detail exposure prevents leaking sensitive info in production
  - All errors logged to console for debugging, should integrate with structured logging service later
---

## US-007: Create users and refresh_tokens database schema
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/db/schema/users.ts with users table
  - Columns: id (UUID PK), email (unique), display_name, avatar_url (nullable), tier (default 'free'), password_hash (nullable), auth_provider (default 'email'), auth_provider_id (nullable), created_at, updated_at
  - Supports multiple authentication providers: email/password, Google OAuth, Apple Sign In
- Created refresh_tokens table
  - Columns: id (UUID PK), user_id (FK to users with CASCADE delete), token_hash, expires_at, is_revoked (default false), created_at
  - Supports token rotation for enhanced security
- Created src/db/schema/index.ts barrel export for clean imports across the codebase
- All column names use snake_case convention (display_name, avatar_url, auth_provider, etc.)
- npm run build passes with zero errors
- Files changed: src/db/schema/users.ts (created), src/db/schema/index.ts (created)
- **Learnings for future iterations:**
  - Drizzle ORM uses camelCase in TypeScript but automatically maps to snake_case in SQL
  - Use .references() for foreign keys with onDelete: 'cascade' for automatic cleanup
  - Use .defaultRandom() for UUID primary keys (generates UUIDv4 at database level)
  - Nullable fields (password_hash, avatar_url, auth_provider_id) allow flexibility for different auth flows
  - password_hash nullable because OAuth users don't have passwords
  - auth_provider_id stores the provider's unique ID for the user (Google sub, Apple user ID, etc.)
  - Refresh tokens stored hashed for security, never stored in plaintext
  - Token rotation requires new token generation and old token revocation on each refresh
---

## US-008: Create stocks database schema
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/db/schema/stocks.ts with stocks table
  - Columns: id (UUID PK), ticker (unique), name, exchange, sector, market_cap (double precision), price (double precision), price_change (double precision), vetr_score (integer), updated_at (timestamp)
  - All column names use snake_case convention (market_cap, price_change, vetr_score, updated_at)
- Added indexes on ticker, sector, and exchange for optimal query performance
- Exported stocks table from src/db/schema/index.ts barrel export
- npm run build passes with zero errors
- Files changed: src/db/schema/stocks.ts (created), src/db/schema/index.ts (modified)
- **Learnings for future iterations:**
  - Drizzle's index() function takes table columns as parameters for creating indexes
  - Use doublePrecision() for floating-point numbers (market_cap, price, price_change)
  - Use integer() for whole numbers (vetr_score)
  - ticker field is unique and indexed for fast lookups
  - Indexes on sector and exchange enable efficient filtering and searching
  - updatedAt timestamp uses defaultNow() for automatic timestamp management
  - All schema files follow consistent pattern: pgTable definition with indexes callback
---
## US-009: Create filings and filing_reads database schema
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/db/schema/filings.ts with filings table
  - Columns: id (UUID PK), stock_id (FK to stocks with CASCADE delete), type, title, date (timestamp), summary (text), is_material (boolean default false), source_url (nullable), created_at
  - Supports multiple filing types: MD&A, Press Release, Financial Statements, Technical Report
- Created filing_reads join table for per-user read tracking
  - Composite primary key (user_id, filing_id) ensures one read record per user per filing
  - Foreign keys to users and filings tables with CASCADE delete for automatic cleanup
  - read_at timestamp tracks when user marked filing as read
- Added indexes on stock_id and date for optimal query performance
- Exported from schema/index.ts barrel export
- npm run build passes with zero errors
- Files changed: src/db/schema/filings.ts (created), src/db/schema/index.ts (modified), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - Composite primary keys use primaryKey({ columns: [col1, col2] }) in table definition callback
  - Join tables for many-to-many relationships use composite PKs instead of separate id column
  - text() type in Drizzle for long-form content without length restrictions (better than varchar for summaries)
  - Boolean fields with default values provide sensible defaults (is_material defaults to false)
  - Foreign key CASCADE deletes ensure referential integrity (deleting stock removes all its filings)
  - Indexes on foreign keys (stock_id) and frequently queried columns (date) improve query performance
  - Per-user read status pattern: join table with user_id + entity_id composite PK
---

## US-010: Create executives database schema
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/db/schema/executives.ts with executives table
  - Columns: id (UUID PK), stock_id (FK to stocks with CASCADE delete), name, title, years_at_company (double precision), previous_companies (jsonb array), education, specialization, social_linkedin (nullable), social_twitter (nullable), created_at, updated_at
  - All column names use snake_case convention for consistency with database standards
- Added indexes on stock_id and name for optimal query performance
  - stock_id index enables efficient lookups of executives by company
  - name index supports efficient search queries by executive name
- Exported from schema/index.ts barrel export for clean imports
- npm run build passes with zero errors
- Files changed: src/db/schema/executives.ts (created), src/db/schema/index.ts (modified), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - jsonb column type with .$type<string[]>() provides type-safe array storage in PostgreSQL
  - previousCompanies uses JSONB to store array of company names for flexible career history tracking
  - Double precision for yearsAtCompany allows fractional years (e.g., 2.5 years)
  - Social media fields (LinkedIn, Twitter) are nullable since not all executives have public profiles
  - Education and specialization are varchar fields with appropriate length constraints
  - Foreign key CASCADE delete ensures executives are automatically removed when stock is deleted
  - Default empty array [] for previousCompanies provides sensible default for new records
  - Indexes on both foreign keys (stock_id) and searchable text fields (name) improve query performance
---

## US-011: Create alert_rules and alerts database schema
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/db/schema/alert-rules.ts with alert_rules table
  - Columns: id (UUID PK), user_id (FK to users with CASCADE delete), stock_ticker, rule_type, trigger_conditions (jsonb), condition_operator (default 'AND'), frequency (default 'instant'), threshold (nullable double precision), is_active (default true), created_at, last_triggered_at (nullable)
  - Supports flexible alert rules with JSONB trigger conditions for complex logic
- Created src/db/schema/alerts.ts with alerts table
  - Columns: id (UUID PK), user_id (FK to users with CASCADE delete), stock_id (FK to stocks with CASCADE delete), alert_rule_id (FK to alert_rules with SET NULL), alert_type, title, message (text), triggered_at, is_read (default false)
  - alert_rule_id nullable allows manually-triggered alerts not associated with rules
- Added indexes on user_id and stock_ticker for alert_rules table for optimal query performance
- Added indexes on user_id, stock_id, and alert_rule_id for alerts table
- Exported both schemas from schema/index.ts barrel export
- npm run build passes with zero errors
- Files changed: src/db/schema/alert-rules.ts (created), src/db/schema/alerts.ts (created), src/db/schema/index.ts (modified)
- **Learnings for future iterations:**
  - JSONB with .$type<Record<string, any>>() provides flexible storage for complex trigger conditions
  - alert_rule_id uses 'set null' onDelete to preserve alert history even after rule deletion
  - Separate alert_rules (configuration) from alerts (triggered events) enables rule reuse and historical tracking
  - Indexed foreign keys (user_id, stock_id, alert_rule_id) ensure efficient queries for user alerts and stock-specific alerts
  - doublePrecision for threshold field allows decimal values (e.g., price thresholds like 12.75)
  - conditionOperator field enables AND/OR logic for multiple trigger conditions in a single rule
  - frequency field supports different alert cadences: instant, daily, weekly, etc.
  - isActive flag allows disabling rules without deletion, preserving configuration
---
---

## US-012: Create watchlist_items database schema
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/db/schema/watchlists.ts with watchlist_items table
  - Columns: user_id (UUID FK to users with CASCADE delete), stock_id (UUID FK to stocks with CASCADE delete), added_at (timestamp with defaultNow())
  - Composite primary key (user_id, stock_id) ensures one watchlist entry per user per stock
  - Foreign keys with CASCADE delete for automatic cleanup when user or stock is deleted
- Added index on user_id for efficient "get user's watchlist" queries
- Exported watchlistItems table from schema/index.ts barrel export
- npm run build passes with zero errors
- Files changed: src/db/schema/watchlists.ts (created), src/db/schema/index.ts (modified)
- **Learnings for future iterations:**
  - Watchlist uses many-to-many relationship pattern with composite PK on join table
  - Tier limits (FREE=5, PRO=25, PREMIUM=unlimited) enforced at service layer, not database
  - Composite primaryKey() syntax: primaryKey({ columns: [table.col1, table.col2] })
  - Index on userId enables efficient filtering of watchlist items by user
  - CASCADE delete on both foreign keys ensures referential integrity (removing user or stock cleans up watchlist entries)
  - addedAt timestamp useful for "recently added" sorting and tracking when stocks were added to watchlist
  - Pattern follows same conventions as filing_reads join table (composite PK, FKs with CASCADE)
---

## US-013: Create vetr_score_history database schema
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/db/schema/vetr-scores.ts with vetr_score_history table
  - Columns: id (UUID PK), stock_ticker, overall_score (int), pedigree_score (int), filing_velocity_score (int), red_flag_score (int), growth_score (int), governance_score (int), bonus_points (int default 0), penalty_points (int default 0), calculated_at (timestamp with defaultNow())
  - All column names use snake_case convention for consistency with database standards
- Added indexes on stock_ticker and calculated_at for optimal query performance
  - stock_ticker index enables efficient lookups of score history by company
  - calculated_at index supports efficient time-based queries and sorting
- Exported vetrScoreHistory table from schema/index.ts barrel export
- npm run build passes with zero errors
- Files changed: src/db/schema/vetr-scores.ts (created), src/db/schema/index.ts (modified), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - VETR Score breakdown into 5 component scores (pedigree, filing_velocity, red_flag, growth, governance) enables detailed analysis
  - Bonus and penalty points stored separately allow tracking of adjustments to base score
  - Historical tracking via calculated_at timestamp enables trend analysis over time
  - stock_ticker stored as varchar instead of FK to stocks table - provides flexibility if score calculated before stock fully onboarded
  - All score fields are integers (0-100 range) for consistency with VETR Score algorithm
  - Default values for bonusPoints and penaltyPoints (0) ensure clean data when no adjustments applied
  - Index on calculated_at crucial for time-series queries (e.g., "get score history for last 6 months")
  - Pattern follows same conventions as other schema files (pgTable with indexes callback)
---

## US-014: Create red_flag_history, red_flag_acknowledgments, sync_history, user_settings schemas
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/db/schema/red-flags.ts with red_flag_history and red_flag_acknowledgments tables
  - red_flag_history: id (UUID PK), stock_ticker, flag_type, severity, score (double), description (text), detected_at
  - Indexes on stock_ticker, detected_at, and flag_type for optimal query performance
  - red_flag_acknowledgments: composite PK (user_id, red_flag_id), acknowledged_at timestamp
  - Supports per-user acknowledgment of red flags with CASCADE delete for referential integrity
- Created src/db/schema/sync.ts with sync_history table
  - Columns: id (UUID PK), user_id (FK to users), started_at, completed_at (nullable), items_synced (int default 0), status, errors (text nullable)
  - Indexes on user_id and started_at for efficient sync history queries
  - Tracks sync operations for offline-first mobile app functionality
- Created src/db/schema/user-settings.ts with user_settings table
  - Columns: id (UUID PK), user_id (unique FK to users), settings (jsonb default {}), updated_at
  - One settings record per user, stored as flexible JSONB for extensibility
- Exported all new schemas from schema/index.ts barrel export
- npm run build passes with zero errors
- Files changed: src/db/schema/red-flags.ts (created), src/db/schema/sync.ts (created), src/db/schema/user-settings.ts (created), src/db/schema/index.ts (modified)
- **Learnings for future iterations:**
  - Index syntax in Drizzle: import `index` from drizzle-orm/pg-core, use `index('name').on(table.column)` pattern
  - Red flag severity levels: Low (<30), Moderate (30-60), High (60-85), Critical (>85) will be used in detection service
  - Red flag types will include: consolidation_velocity, financing_velocity, executive_churn, disclosure_gaps, debt_trend
  - Sync status values: pending, success, failed (simple state machine for sync operations)
  - User settings as JSONB allows flexible schema-free storage for app preferences, notification settings, etc.
  - Composite PK on red_flag_acknowledgments prevents duplicate acknowledgments (one per user per flag)
  - All tables follow established patterns: UUID PKs with defaultRandom(), snake_case column names, appropriate indexes
  - Text type for errors field allows storing detailed error messages from failed sync operations
---

## US-015: Create Zod request validation middleware
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/middleware/validator.ts with comprehensive Zod validation middleware
- Implemented zValidator() factory function that validates request body, query params, or route params
- Returns 422 VALIDATION_ERROR with structured error details on validation failure
- Supports all three validation targets: 'body', 'query', and 'params'
- Added convenience functions: validateBody(), validateQuery(), validateParams()
- Error handling includes:
  - Zod validation errors with formatted issues (path, message, code)
  - JSON parsing errors for invalid request bodies
  - Proper integration with existing ValidationError class
- npm run build passes with zero errors
- Files changed: src/middleware/validator.ts (created), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - Hono middleware signature is (c: Context, next) => Promise<void>
  - Use schema.safeParse() instead of parse() to avoid throwing ZodError directly
  - Extract data from request using c.req.json() for body, c.req.query() for query, c.req.param() for params
  - Validation errors should be thrown as ValidationError instances for consistent error handling
  - Error details include target (body/query/params) and formatted issues array
  - Handle JSON parsing errors separately from validation errors (SyntaxError for invalid JSON)
  - TypeScript generics on zValidator<T extends ZodSchema> enable type inference
  - Middleware factory pattern allows reusable validation logic across all routes
  - Always await next() to continue middleware chain after successful validation
---

## US-016: Register all middleware on Hono app
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Updated src/app.ts to register all middleware in proper order:
  1. Request ID generation middleware (crypto.randomUUID())
  2. Logger middleware (Hono's built-in logger)
  3. CORS middleware with environment-based configuration
  4. Error handler (registered via app.onError())
- Added CORS_ORIGIN environment variable to src/config/env.ts with default value '*'
- Configured CORS middleware to use env.CORS_ORIGIN with credentials: true
- Added Hono context type extension (Variables type) to support requestId in context
- Request ID stored in context via c.set('requestId', ...) for use in response builders and logging
- Verified /v1/health endpoint works correctly after middleware registration
- npm run build passes with zero errors
- Files changed: src/app.ts (modified), src/config/env.ts (modified), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - Hono requires explicit type definition for context variables via Variables type parameter: `Hono<{ Variables: VariablesType }>`
  - Middleware order matters: request ID should be first so it's available for logger and error handler
  - CORS middleware accepts origin parameter that can be string (single origin), array (multiple origins), or '*' (all origins)
  - credentials: true in CORS config allows cookies and authorization headers in cross-origin requests
  - crypto.randomUUID() is Node.js built-in (Node 20+), no external dependency needed
  - Context variables set via c.set() are available in subsequent middleware and route handlers via c.get()
  - Type safety for context variables prevents runtime errors from typos in variable names
  - Environment-based CORS config enables different origins for dev/staging/production environments
---

## US-017: Create health check route with DB and Redis status
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/routes/health.routes.ts with comprehensive health check endpoint
- Moved health check from inline definition in app.ts to dedicated routes file
- Added database connectivity check using simple SELECT 1 query via Drizzle
- Added Redis connectivity check using ping() command
- Returns detailed status information:
  - Overall status: 'healthy' (DB connected) or 'degraded' (DB unavailable/error)
  - Version: 1.0.0
  - Uptime in seconds (calculated from server start time)
  - Timestamp in ISO 8601 format
  - Database status: connected, unavailable, or error (with error message)
  - Redis status: connected, unavailable, or error (with error message)
- Gracefully handles null db/redis instances (development mode)
- Registered health routes on main app using app.route('/health', healthRoutes)
- npm run build passes with zero errors
- Files changed: src/routes/health.routes.ts (created), src/app.ts (modified), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - Health check endpoints should always report connectivity for external dependencies
  - Use simple queries (SELECT 1, PING) to verify connectivity without heavy operations
  - Store server start time at module level for uptime calculation (Date.now() - startTime)
  - Overall health should be 'degraded' if critical services (DB) are unavailable, but 'healthy' if only cache (Redis) is down
  - Error messages should be included in response for debugging, but only when errors occur
  - Hono's app.route() method registers a group of routes under a common path prefix
  - Health check pattern: unavailable (not configured), connected (working), error (configured but failing)
  - SQL tagged template literal from drizzle-orm for raw queries: sql`SELECT 1`
  - Redis ping() method returns "PONG" string on success, throws on failure
---

## US-018: Set up OpenAPI spec generation with Zod schemas
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Replaced standard Hono instance with OpenAPIHono from @hono/zod-openapi package
- Configured OpenAPI 3.0 specification directly in src/app.ts using app.doc() method
- Created base OpenAPI config with:
  - Title: "VETTR API"
  - Version: "1.0.0"
  - Description: Comprehensive REST API for stock analysis
  - Server definition: /v1 base path
  - Tags for all route groups: health, auth, stocks, filings, executives, vetr-score, red-flags, alerts, watchlist, sync, users
- Exposed OpenAPI JSON spec at GET /v1/openapi.json
- Created src/config/openapi.ts with ErrorResponseSchema for future use (though main config is in app.ts)
- Verified endpoint returns proper OpenAPI 3.0 JSON with all tags and metadata
- npm run build passes with zero errors
- Files changed: src/app.ts (modified), src/config/openapi.ts (created)
- **Learnings for future iterations:**
  - @hono/zod-openapi replaces standard Hono import with OpenAPIHono class
  - app.doc(path, config) method registers OpenAPI spec endpoint and configuration
  - OpenAPIHono is fully compatible with standard Hono middleware (logger, cors, error handler)
  - Tags defined in OpenAPI config will be used for route grouping in Swagger UI
  - OpenAPI spec auto-generates paths:{} and components:{} sections, populated when routes are registered
  - Future routes should use createRoute() from @hono/zod-openapi for automatic schema documentation
  - ErrorResponseSchema useful for standardizing error documentation across all endpoints
  - OpenAPI 3.0 format required for Swagger UI compatibility
  - Server URL should match app basePath for correct endpoint URLs in documentation
---

## US-019: Configure Swagger UI documentation endpoint
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Set up @hono/swagger-ui at GET /v1/docs endpoint in src/app.ts
- Imported swaggerUI from @hono/swagger-ui (already installed as dependency v0.4.1)
- Configured Swagger UI to point to /v1/openapi.json spec endpoint
- Placed Swagger UI registration after OpenAPI doc config and before middleware registration
- npm run build passes with zero errors
- Files changed: src/app.ts (modified)
- **Learnings for future iterations:**
  - @hono/swagger-ui exports a swaggerUI() function that returns a Hono handler
  - swaggerUI({ url: '/v1/openapi.json' }) needs the full path including the basePath prefix
  - The handler is registered with app.get('/docs', swaggerUI(...)) ‚Äî it serves the HTML page with embedded Swagger UI
  - Swagger UI must be registered before wildcard middleware to avoid conflicts
  - The OpenAPI spec at /v1/openapi.json is auto-populated as routes are registered via @hono/zod-openapi
  - This was a minimal change ‚Äî just 2 lines added (import + route registration)
---

## US-020: Create stock seed data (25 Canadian pilot stocks)
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/db/seed/stocks.ts with 25 Canadian stock seed data entries
- Stocks include: NXE, ARIS, LUN, FM, TKO, ERO, CS, MAG, FVI, WPM, AEM, OR, ELD, SII, BTO, NGD, IMG, MND, LUG, KRR, RIO, SBB, GPL, FR, AG
- Exchanges represented: TSX (majority), TSXV (RIO), NYSE (AG)
- Sectors covered: Uranium, Gold, Base Metals, Copper, Silver, Precious Metals, Financial Services
- Each stock includes realistic: ticker, name, exchange, sector, market_cap, price, price_change, vetr_score
- Exported seedStocks() function using Drizzle upsert (onConflictDoUpdate on ticker) for idempotent re-seeding
- Market caps range from $95M (GPL) to $42.3B (AEM) for realistic distribution
- VETR scores range from 35 (GPL) to 91 (AEM) for varied scoring
- npm run build passes with zero errors
- Files changed: src/db/seed/stocks.ts (created)
- **Learnings for future iterations:**
  - Drizzle's onConflictDoUpdate() enables upsert pattern on unique columns (ticker)
  - Set clause in onConflictDoUpdate excludes the conflict target column (ticker)
  - seedStocks() is async and returns count for progress reporting
  - Null check on db instance enables graceful skip when DATABASE_URL not configured
  - Stock data follows the exact column names from the stocks schema (camelCase in TypeScript)
  - Created seed directory at src/db/seed/ for all seed files
---

## US-021: Create filing seed data
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/db/seed/filings.ts with 75 filings (3 per stock for all 25 Canadian pilot stocks)
- Filing types used: MD&A, Press Release, Financial Statements, Technical Report
- Each filing includes realistic: type, title, date (last 6 months: Aug-Nov 2025), summary, isMaterial flag, sourceUrl (nullable)
- Exported seedFilings() function that looks up stock IDs by ticker before inserting filings
- Handles missing stocks gracefully (skips with warning)
- Null check on db instance for development mode without DATABASE_URL
- npm run build passes with zero errors
- Files changed: src/db/seed/filings.ts (created)
- **Learnings for future iterations:**
  - Filing seed data needs stock IDs (UUIDs) from database, so must look up by ticker at seed time
  - Used eq() from drizzle-orm for WHERE clause filtering on ticker
  - Filings table uses stockId (UUID FK) not ticker string, unlike vetr_score_history which uses stock_ticker
  - Simple insert (not upsert) used since filings don't have a unique constraint to conflict on
  - TypeScript interface FilingSeed defined for type-safe seed data structure
  - sourceUrl is nullable - not all filings have public URLs (e.g., financial statements filed via SEDAR)
  - isMaterial flag distinguishes significant filings (technical reports, major announcements) from routine ones
  - Dates spread across Aug-Nov 2025 for realistic 6-month filing history
---

## US-022: Create executive seed data
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/db/seed/executives.ts with 3-5 executives per stock for all 25 Canadian pilot stocks
- Total of ~93 executives across all stocks with realistic data
- Executive roles include: CEO, CFO, COO, VP Exploration, VP Operations, CTO, General Counsel, SVP Technical Services, etc.
- Each executive includes: name, title, yearsAtCompany, previousCompanies (JSON array), education, specialization
- socialLinkedin and socialTwitter set to null (as seed data)
- Follows same pattern as filings.ts: looks up stock ID by ticker before inserting executives
- Null check on db instance for development mode without DATABASE_URL
- AG (NYSE) shares same executives as FR (TSX) since they represent the same company listed on different exchanges
- npm run build passes with zero errors
- Files changed: src/db/seed/executives.ts (created), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - Executive seed data needs stock IDs (UUIDs) from database, same pattern as filings seed
  - Used eq() from drizzle-orm for WHERE clause filtering on ticker
  - Simple insert (not upsert) used since executives don't have a unique constraint to conflict on
  - previousCompanies stored as string[] in JSONB column, matching schema definition
  - yearsAtCompany uses decimal values (e.g., 10.5) for fractional years, matching doublePrecision schema
  - Realistic mining industry titles and career histories (Canadian mining companies, Big Four accounting firms, etc.)
  - Specializations reflect real mining disciplines: heap leach, SX-EW processing, epithermal deposits, etc.
  - Education includes professional designations relevant to mining: P.Eng, P.Geo, CPA, CFA
---

## US-023: Create seed runner script and database initialization
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/db/seed/index.ts with runAllSeeds() function that orchestrates all seed operations
  - Runs seeds in correct dependency order: stocks first, then filings, then executives
  - Stocks use upsert (onConflictDoUpdate) so re-running is safe and idempotent
  - Filings and executives are cleared before re-seeding (DELETE then INSERT) since they lack unique constraints
  - Logs progress for each step and prints summary with counts and duration
  - Exits with error if DATABASE_URL not configured
- Created scripts/seed.ts as entry point for npm run db:seed
  - Imports and calls runAllSeeds() from src/db/seed/index.ts
  - Handles success (exit 0) and failure (exit 1) with error logging
  - Runs via tsx: `npm run db:seed` -> `tsx scripts/seed.ts`
- npm run build passes with zero errors
- Files changed: src/db/seed/index.ts (created), scripts/seed.ts (created)
- **Learnings for future iterations:**
  - Filings and executives use simple insert() without unique constraints, so must DELETE before re-seeding to avoid duplicates
  - Stocks use upsert via onConflictDoUpdate on ticker, making re-seeding idempotent
  - CASCADE delete on foreign keys means deleting stocks would also delete filings/executives, but we delete filings/executives explicitly first for clarity
  - The db:seed npm script was already defined in package.json pointing to `tsx scripts/seed.ts`
  - tsx runs TypeScript files directly without compilation, useful for scripts
  - process.exit(0) needed in seed script to close database pool connections
---

## US-024: Create JWT utility functions
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/utils/jwt.ts with four utility functions:
  - signAccessToken(payload): Signs JWT with { sub, email, tier } using HS256, 15min TTL
  - signRefreshToken(): Generates opaque UUID string with 30-day expiry date
  - verifyAccessToken(token): Verifies JWT signature and expiry, returns typed AccessTokenPayload
  - decodeToken(token): Decodes token without verification for debugging/inspection
- Exported AccessTokenPayload interface for use by auth middleware and services
- Uses jsonwebtoken package with HS256 algorithm and JWT_SECRET from env config
- Refresh tokens are opaque UUIDs (not JWTs) ‚Äî stored hashed in DB by auth service
- npm run build passes with zero errors
- Files changed: src/utils/jwt.ts (created)
- **Learnings for future iterations:**
  - jsonwebtoken's sign() accepts expiresIn as string shorthand ('15m', '30d', etc.)
  - verify() should specify algorithms array to prevent algorithm confusion attacks
  - Refresh tokens as opaque UUIDs are simpler and more secure than JWT refresh tokens
  - crypto.randomUUID() is Node.js 20+ built-in, no need for uuid package for this use case
  - decode() returns string | JwtPayload | null ‚Äî need type narrowing for safe usage
  - AccessTokenPayload interface will be reused by auth middleware (c.set('user', payload))
  - JWT_SECRET has development default in env.ts, but should be overridden in production
---

## US-025: Create password utility functions
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/utils/password.ts with three utility functions:
  - hashPassword(password): Hashes plaintext password using bcrypt with cost factor 12
  - comparePassword(password, hash): Compares plaintext password against bcrypt hash
  - validatePasswordStrength(password): Validates min 8 chars, at least 1 uppercase, at least 1 number
- Exported PasswordValidationResult interface with valid boolean and errors string array
- Uses async bcrypt.hash() and bcrypt.compare() (never sync versions)
- npm run build passes with zero errors
- Files changed: src/utils/password.ts (created), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - bcrypt cost factor 12 provides good security/performance balance
  - bcrypt.hash() and bcrypt.compare() are async and return Promises
  - Password validation is synchronous (pure string checks), no need for async
  - Regex patterns: /[A-Z]/ for uppercase, /[0-9]/ for digits
  - PasswordValidationResult interface with errors array provides descriptive feedback to clients
  - validatePasswordStrength collects all errors (doesn't short-circuit) so users see all issues at once
---

## US-026: Create auth middleware for JWT verification
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/middleware/auth.ts with authMiddleware function
  - Extracts Bearer token from Authorization header
  - Verifies JWT signature and expiry using verifyAccessToken() from utils/jwt.ts
  - Attaches user info { id, email, tier } to Hono context via c.set('user', ...)
  - Returns 401 AUTH_REQUIRED if no token or invalid token
  - Returns 401 AUTH_EXPIRED if token has expired (checks error.name === 'TokenExpiredError')
- Exported AuthUser interface for type-safe context access across routes
- Updated src/app.ts Variables type to include `user: AuthUser` for type-safe c.get('user')
- Imported AuthUser type in app.ts for context variable type definition
- npm run build passes with zero errors
- Files changed: src/middleware/auth.ts (created), src/app.ts (modified)
- **Learnings for future iterations:**
  - Hono middleware signature: (c: Context, next: Next) => Promise<void>
  - Use error.name === 'TokenExpiredError' instead of instanceof for CJS/ESM interop safety with jsonwebtoken
  - AuthUser interface maps JWT payload.sub to id for cleaner route handler API
  - Variables type in app.ts must include all context variables used by middleware (requestId, user)
  - Bearer token extraction: authHeader.slice(7) after verifying startsWith('Bearer ')
  - Re-throw AppError instances in catch block to avoid wrapping known errors
  - Routes use c.get('user') to access authenticated user ‚Äî type-safe via Variables type
---

## US-027: Create auth service for user management
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/services/auth.service.ts with comprehensive user management and token operations
  - createUser(input): Creates new user, checks for email uniqueness, throws ConflictError on duplicate
  - findByEmail(email): Looks up user by email, returns UserRow or null
  - findByProviderId(provider, providerId): Looks up user by OAuth provider ID (Google, Apple), returns UserRow or null
  - updateUser(userId, input): Updates user profile fields (displayName, avatarUrl, tier), sets updatedAt
  - storeRefreshToken(userId): Generates refresh token via signRefreshToken(), hashes with bcrypt cost 12, stores in refresh_tokens table
  - verifyRefreshToken(userId, rawToken): Iterates user's non-revoked, non-expired tokens and bcrypt.compare() against stored hashes
  - revokeRefreshToken(tokenId): Sets is_revoked=true for a specific token
  - revokeAllRefreshTokens(userId): Revokes all tokens for a user (for password change/compromise scenarios)
- Exported TypeScript interfaces: CreateUserInput, UpdateUserInput, UserRow (inferred from schema)
- All functions check for null db instance and throw InternalError if unavailable
- Uses Drizzle ORM with eq() filter, .returning() for insert/update results
- npm run build passes with zero errors
- Files changed: src/services/auth.service.ts (created), scripts/ralph/prd.json (modified), scripts/ralph/progress.txt (modified)
- **Learnings for future iterations:**
  - Drizzle's .$inferSelect type utility provides TypeScript types from schema definitions without manual interface duplication
  - .returning() on insert/update returns the full row including generated columns (id, created_at, etc.)
  - Refresh token verification requires iterating and bcrypt.compare() on each ‚Äî no way to query by hash directly
  - ConflictError (409) is the appropriate error for duplicate email registration
  - Pattern: check-then-insert for uniqueness (race condition acceptable for email registration use case)
  - bcrypt import requires `import bcrypt from 'bcrypt'` (default export) in ESM
  - Service functions are pure functions that accept parameters and return typed results, no class needed
---

## US-028: Implement POST /v1/auth/signup endpoint
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/routes/auth.routes.ts with POST /auth/signup endpoint
  - Validates request body with Zod: email (valid email), password (non-empty string), display_name (1-255 chars)
  - Validates password strength via validatePasswordStrength() (min 8 chars, 1 uppercase, 1 number)
  - Hashes password with bcrypt cost factor 12
  - Creates user in database via auth.service.ts createUser()
  - Generates JWT access token (15min TTL) with { sub, email, tier }
  - Generates and stores hashed refresh token (30-day TTL)
  - Returns 201 with { access_token, refresh_token, token_type: "Bearer", expires_in: 900, user: UserDto }
  - Rejects duplicate emails with ConflictError (409)
- Registered auth routes on main app in src/app.ts via app.route('/auth', authRoutes)
- UserDto in response uses snake_case fields: display_name, avatar_url, auth_provider, created_at, updated_at
- npm run build and npm run typecheck both pass with zero errors
- Files changed: src/routes/auth.routes.ts (created), src/app.ts (modified)
- **Learnings for future iterations:**
  - Hono routes use plain Hono() instances (not OpenAPIHono) for route groups mounted on the main app
  - validateBody() middleware from validator.ts validates request body before handler executes
  - Two-phase password validation: Zod validates presence/format, validatePasswordStrength() validates security requirements
  - User creation throws ConflictError which global error handler catches and returns as 409
  - Response uses success() builder from utils/response.ts which adds meta { timestamp, request_id }
  - snake_case conversion needed manually in route handler when mapping Drizzle camelCase fields to API response
  - HTTP 201 Created is the correct status for successful resource creation
  - Auth routes mounted at /auth prefix, so full path is /v1/auth/signup
---

## US-029: Implement POST /v1/auth/login endpoint
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Added POST /auth/login endpoint to src/routes/auth.routes.ts
  - Validates request body with Zod: email (valid email), password (non-empty string)
  - Finds user by email via findByEmail() from auth.service.ts
  - Verifies user has a password hash (rejects OAuth-only accounts with same generic error)
  - Compares password with bcrypt via comparePassword() from utils/password.ts
  - Generates JWT access token (15min TTL) with { sub, email, tier }
  - Generates and stores hashed refresh token (30-day TTL)
  - Returns 200 with same shape as signup: { access_token, refresh_token, token_type, expires_in, user: UserDto }
  - Returns AUTH_INVALID_CREDENTIALS (401) on failure with generic "Invalid email or password" message
- Added imports for findByEmail, comparePassword, AuthInvalidCredentialsError
- npm run build and npm run typecheck both pass with zero errors
- Files changed: src/routes/auth.routes.ts (modified)
- **Learnings for future iterations:**
  - Login uses same response shape as signup for client consistency
  - Generic error message "Invalid email or password" prevents email enumeration attacks
  - OAuth-only accounts (no passwordHash) handled with same generic error as wrong password
  - Login returns HTTP 200 (not 201) since no resource is created
  - comparePassword() from utils/password.ts wraps bcrypt.compare() for consistent async interface
  - AuthInvalidCredentialsError maps to 401 status with AUTH_INVALID_CREDENTIALS error code
---

## US-030: Implement POST /v1/auth/google endpoint
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Added POST /auth/google endpoint to src/routes/auth.routes.ts
  - Validates request body with Zod: { id_token } (non-empty string)
  - Verifies Google ID token via https://oauth2.googleapis.com/tokeninfo endpoint
  - Extracts email, name, picture from verified token claims
  - Upserts user (creates if new with provider='google', updates if existing)
  - Returns 200 with { access_token, refresh_token, token_type, expires_in, user: UserDto }
- Added verifyGoogleToken() to src/services/auth.service.ts
  - Calls Google tokeninfo endpoint with the provided id_token
  - Validates audience (aud) matches GOOGLE_CLIENT_ID from env (if configured)
  - Throws AuthInvalidCredentialsError on invalid token or audience mismatch
  - Returns typed GoogleTokenInfo with sub, email, name, picture
- Added upsertOAuthUser() to src/services/auth.service.ts
  - First checks by provider ID (findByProviderId), then by email (findByEmail)
  - Links OAuth provider to existing email account if found
  - Creates new user if no existing account found
  - Reusable for Apple OAuth (US-031) implementation
- npm run build and npm run typecheck both pass with zero errors
- Files changed: src/routes/auth.routes.ts (modified), src/services/auth.service.ts (modified)
- **Learnings for future iterations:**
  - Google tokeninfo endpoint: GET https://oauth2.googleapis.com/tokeninfo?id_token=TOKEN
  - Response.json() returns `unknown` type in strict TypeScript - need explicit `as Type` assertion
  - encodeURIComponent() on the id_token prevents URL injection when constructing tokeninfo URL
  - upsertOAuthUser pattern: check provider ID first, then email, then create new - handles account linking
  - GOOGLE_CLIENT_ID optional in env.ts - audience check skipped when not configured (useful for dev)
  - The upsertOAuthUser function is generic enough to reuse for Apple Sign In (US-031)
  - OAuth users don't have password_hash - login endpoint handles this by returning generic error
---

## US-031: Implement POST /v1/auth/apple endpoint
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Added POST /auth/apple endpoint to src/routes/auth.routes.ts
  - Validates request body with Zod: { identity_token, authorization_code, user?: { email, name } }
  - Verifies Apple identity_token by fetching JWKS and validating JWT signature
  - Validates token claims: iss (https://appleid.apple.com), aud (APPLE_CLIENT_ID if configured)
  - Handles first sign-in user object (Apple only sends name/email on first auth)
  - Upserts user (create if new with provider='apple', update if existing)
  - Returns 200 with { access_token, refresh_token, token_type, expires_in, user: UserDto }
- Added verifyAppleToken() to src/services/auth.service.ts
  - Decodes JWT header to extract kid (key ID)
  - Fetches Apple JWKS from https://appleid.apple.com/auth/keys with 24h cache
  - Finds matching key by kid and converts JWK to PEM using Node's crypto.createPublicKey
  - Verifies token with jsonwebtoken.verify() using RS256 algorithm
  - Validates issuer and audience claims
  - Returns typed AppleTokenClaims with sub, email, email_verified
- Reused existing upsertOAuthUser() function from US-030 with provider='apple'
- APPLE_CLIENT_ID already in env.ts from US-002 (optional, audience check skipped when not configured)
- npm run build and npm run typecheck both pass with zero errors
- Files changed: src/services/auth.service.ts (modified), src/routes/auth.routes.ts (modified), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - Apple uses RS256 (RSA) for signing identity tokens, unlike Google which uses tokeninfo endpoint
  - jwt.decode(token, { complete: true }) returns header + payload for extracting kid
  - crypto.createPublicKey({ key: jwk, format: 'jwk' }) converts JWK to crypto.KeyObject in Node.js
  - KeyObject.export({ type: 'spki', format: 'pem' }) converts to PEM string for jsonwebtoken.verify()
  - Apple JWKS should be cached to avoid fetching on every auth request (24h TTL sufficient since keys rotate slowly)
  - Apple only sends user name/email on the FIRST sign-in - subsequent sign-ins only have identity_token
  - Email may come from token claims or from the user object (first sign-in), need to check both
  - authorization_code accepted in request but not used server-side (used for server-to-server token exchange if needed)
  - upsertOAuthUser() from US-030 worked without modification for Apple Sign In
---

## US-032: Implement POST /v1/auth/refresh endpoint
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Added POST /auth/refresh endpoint to src/routes/auth.routes.ts
  - Validates request body with Zod: { refresh_token } (non-empty string)
  - Finds and verifies refresh token across all non-revoked, non-expired tokens via findAndVerifyRefreshToken()
  - Revokes old refresh token (token rotation) via revokeRefreshToken()
  - Looks up user by ID to get current profile data for new access token
  - Generates new JWT access token (15min TTL) with current { sub, email, tier }
  - Generates and stores new hashed refresh token (30-day TTL)
  - Returns 200 with same shape as login/signup: { access_token, refresh_token, token_type, expires_in, user: UserDto }
  - Returns AUTH_INVALID_CREDENTIALS (401) if token is invalid, expired, or revoked
- Added findAndVerifyRefreshToken() to src/services/auth.service.ts
  - Queries all non-revoked refresh tokens and bcrypt.compare() against each
  - Filters out expired tokens before comparison
  - Returns matching token row and userId for token rotation and user lookup
- Added findById() to src/services/auth.service.ts for looking up user by UUID
- npm run build and npm run typecheck both pass with zero errors
- Files changed: src/routes/auth.routes.ts (modified), src/services/auth.service.ts (modified), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - Opaque UUID refresh tokens cannot be looked up by hash directly - must iterate and bcrypt.compare()
  - findAndVerifyRefreshToken() searches all non-revoked tokens (no userId required from client)
  - Token rotation: revoke old token BEFORE generating new one to prevent reuse
  - findById() utility needed for refresh flow since we only have userId from the token row
  - Refresh endpoint does NOT require auth middleware (client may have expired access token)
  - Same response shape as signup/login for client consistency
  - For production scale, consider storing a token identifier prefix for O(1) lookup instead of O(n) bcrypt iteration
---

## US-033: Implement POST /v1/auth/logout endpoint
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Added POST /auth/logout endpoint to src/routes/auth.routes.ts
  - Requires auth middleware (user must be authenticated to log out)
  - Validates request body with Zod: { refresh_token } (non-empty string)
  - Finds and verifies the refresh token via findAndVerifyRefreshToken()
  - Revokes the refresh token by setting is_revoked=true via revokeRefreshToken()
  - Returns success regardless of whether token was found (prevents token enumeration)
  - Returns 200 with { success: true, data: null }
- Imported authMiddleware from middleware/auth.ts for protected route
- Reused existing service functions: findAndVerifyRefreshToken(), revokeRefreshToken()
- npm run build and npm run typecheck both pass with zero errors
- Files changed: src/routes/auth.routes.ts (modified), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - Logout endpoint REQUIRES auth middleware (unlike refresh which does not)
  - Always return success on logout even if token not found ‚Äî prevents token enumeration attacks
  - Reusing findAndVerifyRefreshToken() + revokeRefreshToken() from auth.service.ts kept implementation minimal
  - success(null) from response builder works cleanly for endpoints that return no data
  - Pattern: auth middleware first, then validation middleware, then handler
---

## US-034: Create tier-based rate limiting middleware
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/middleware/rate-limit.ts with comprehensive tier-based rate limiting
- Used @upstash/ratelimit v2 with sliding window algorithm for smooth rate limiting
- Implemented two middleware functions:
  - rateLimitMiddleware: For general endpoints, auto-detects read/write from HTTP method
  - authRateLimitMiddleware: For auth endpoints with stricter limits
- Rate limits by tier:
  - Unauth: 5/min (all categories)
  - FREE: reads 60/min, writes 30/min, auth 10/min
  - PRO: reads 120/min, writes 60/min, auth 10/min
  - PREMIUM: reads 300/min, writes 120/min, auth 10/min
  - Auth (unauthenticated): 5/min
- Features:
  - Automatic tier detection from Hono context (c.get('user'))
  - Identifier based on user ID (authenticated) or IP address (unauthenticated)
  - Rate limit headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset
  - Retry-After header on 429 responses
  - Lazy Ratelimit instance creation with caching
  - Graceful degradation: skips rate limiting when Redis unavailable (dev mode)
  - Fail-open: allows requests through if Redis errors occur
- npm run build and npm run typecheck both pass with zero errors
- Files changed: src/middleware/rate-limit.ts (created), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - @upstash/ratelimit v2 Ratelimit.slidingWindow() creates the limiter configuration
  - Ratelimit constructor takes { redis, limiter, prefix } options
  - limiter.limit(identifier) returns { success, limit, remaining, reset }
  - Reset value is a Unix timestamp in milliseconds
  - Retry-After header should be in seconds (ceil of (reset - now) / 1000)
  - Lazy initialization with Map cache avoids creating limiters until needed
  - Category detection from HTTP method: GET/HEAD/OPTIONS = read, everything else = write
  - Fail-open pattern: catch Redis errors and allow request through (better than blocking all traffic)
  - Two separate middleware exports allow different rate limit strategies for auth vs general endpoints
  - getTierFromContext() uses try/catch for c.get('user') since it may not be set for unauthenticated requests
---

## US-035: Apply rate limiting to all route groups
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Applied `authRateLimitMiddleware` to all `/auth/*` routes via `authRoutes.use('*', authRateLimitMiddleware)` in auth.routes.ts
- Applied `rateLimitMiddleware` globally in app.ts via `app.use('*', rateLimitMiddleware)`
  - Global middleware auto-detects read/write from HTTP method (GET/HEAD/OPTIONS = read, others = write)
  - Tier detection from auth context (user.tier) with fallback to 'unauth' for unauthenticated requests
- Auth routes get BOTH the global rate limit (read/write) AND the auth-specific rate limit (stricter)
- Rate limiting gracefully skips when Redis is unavailable (dev mode) ‚Äî both middlewares check `if (!redis)` first
- Fail-open pattern: Redis errors caught and request allowed through
- Rate limit headers (X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset) set on all responses
- Retry-After header set on 429 responses
- npm run build passes with zero errors
- Files changed: src/app.ts (modified), src/routes/auth.routes.ts (modified)
- **Learnings for future iterations:**
  - Global rate limiting in app.ts covers all current AND future route groups automatically
  - Auth routes use separate authRateLimitMiddleware with stricter limits (5/min unauth, 10/min auth)
  - Middleware order: request ID ‚Üí logger ‚Üí CORS ‚Üí error handler ‚Üí rate limit ‚Üí routes
  - Rate limit middleware placed after CORS so rate-limited responses include CORS headers
  - When future route groups are added (stocks, filings, etc.), they automatically get rate limiting from the global middleware
  - Auth routes effectively have dual rate limiting: global (read/write) + auth-specific ‚Äî this is intentional as auth endpoints should be extra protected
---

## US-036: Create stock service with pagination and filtering
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/services/stock.service.ts with getStocks() function supporting full query options
- Supports pagination with total count via sql`count(*)::int` query
- Supports filtering by sector and exchange via eq() conditions
- Supports sorting by ticker, name, vetr_score, market_cap, price with asc/desc order
- Supports search by name or ticker using ilike() with wildcard pattern
- Used sql.join() to combine multiple WHERE conditions with AND
- Sort column mapping via sortColumnMap object for type-safe column references
- Returns GetStocksResult with stocks array and PaginationMeta
- npm run build passes with zero errors
- Files changed: src/services/stock.service.ts (created), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - Drizzle's ilike() function handles case-insensitive pattern matching (PostgreSQL ILIKE)
  - or() from drizzle-orm combines conditions with OR logic, returns SQL | undefined so needs ! assertion
  - sql.join() with sql` AND ` separator combines array of conditions into single WHERE clause
  - sql<number>`count(*)::int` provides type-safe count query with PostgreSQL cast to integer
  - asc() and desc() from drizzle-orm wrap columns for ORDER BY direction
  - Pattern: build conditions array, then join for WHERE clause ‚Äî clean and composable
  - sortColumnMap provides safe mapping from API sort parameter to actual Drizzle column reference
  - PaginationMeta.has_more calculated as offset + limit < total
---

## US-037: Implement GET /v1/stocks endpoint
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/routes/stocks.routes.ts with GET /stocks endpoint
  - Applied authMiddleware to all stock routes via stockRoutes.use('*', authMiddleware)
  - Validates query params with Zod: limit (default 20), offset (default 0), sector, exchange, sort (enum), order (enum), search
  - Clamps limit to 1-100 range and offset to 0+ for safety
  - Calls getStocks() from stock.service.ts with parsed and typed query options
  - Maps Drizzle camelCase fields to snake_case for API response (market_cap, price_change, vetr_score, updated_at)
  - Returns paginated response using paginated() builder from utils/response.ts
- Registered stock routes on main app in src/app.ts via app.route('/stocks', stockRoutes)
- npm run build passes with zero errors
- Files changed: src/routes/stocks.routes.ts (created), src/app.ts (modified)
- **Learnings for future iterations:**
  - Query params from Hono are always strings, need parseInt() for numeric values
  - Zod schema validates query param format, but actual parsing/clamping done in handler for safety
  - Sort/order params cast to union type with `as` after Zod validation ensures type safety
  - paginated() helper from response.ts wraps items + pagination in standardized format
  - Stock DTO mapping: Drizzle returns camelCase (marketCap, priceChange, vetrScore), API needs snake_case
  - updatedAt.toISOString() converts Date to ISO 8601 string per API conventions
  - Route pattern: use('*', authMiddleware) then define individual route handlers
---

## US-038: Implement GET /v1/stocks/:ticker endpoint
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Added getStockByTicker() to src/services/stock.service.ts
  - Looks up stock by ticker (case-insensitive via toUpperCase())
  - Returns stock data, executives summary (total count + top 3 by tenure), recent filings (last 5 by date), and is_favorite (per-user watchlist check)
  - Uses Promise.all() for parallel executives + count queries
  - Throws NotFoundError (404) if ticker doesn't exist
- Added GET /stocks/:ticker route to src/routes/stocks.routes.ts
  - Accesses authenticated user via c.get('user') for watchlist check
  - Maps all Drizzle camelCase fields to snake_case for API response
  - Returns executives_summary { total, top: [...] } with full executive DTOs
  - Returns recent_filings array with filing DTOs
  - Returns is_favorite boolean from watchlist lookup
- Added Variables type with AuthUser to stockRoutes Hono instance for type-safe c.get('user')
- npm run build and npm run typecheck both pass with zero errors
- Files changed: src/services/stock.service.ts (modified), src/routes/stocks.routes.ts (modified)
- **Learnings for future iterations:**
  - Route groups using c.get('user') need explicit Variables type: `new Hono<{ Variables: Variables }>()`
  - Plain Hono() instances don't inherit Variables type from parent app
  - AuthUser type must be imported from middleware/auth.ts for type-safe context access
  - and() from drizzle-orm combines conditions for composite WHERE clause (watchlist lookup)
  - Promise.all() for parallel DB queries (executives list + count) improves performance
  - Stock detail pattern: base stock data spread with nested objects for related data
  - is_favorite requires both userId and stockId for watchlist lookup
---

## US-039: Implement GET /v1/stocks/search endpoint with caching
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Added searchStocks() function to src/services/stock.service.ts
  - Searches by name or ticker using ILIKE with wildcard pattern
  - Caches results in Redis for 2 minutes (key: search:{query}:{limit})
  - Cache key uses lowercase query for case-insensitive cache hits
  - Accepts query string and limit parameter (default 10)
  - Results ordered by ticker ascending
- Added GET /stocks/search route to src/routes/stocks.routes.ts
  - Validates query params with Zod: q (required, min 1 char), limit (optional, default 10)
  - Clamps limit to 1-50 range
  - Returns array of StockDto in snake_case format via success() builder
  - Route registered BEFORE /:ticker to avoid "search" matching as a ticker param
- npm run build and npm run typecheck both pass with zero errors
- Files changed: src/services/stock.service.ts (modified), src/routes/stocks.routes.ts (modified)
- **Learnings for future iterations:**
  - Route ordering matters in Hono: /search must be defined before /:ticker parameterized route
  - Cache key pattern: search:{query_lowercase}:{limit} for deterministic keys
  - import * as cache from './cache.service.js' provides clean namespace for cache operations
  - Cache gracefully returns null when Redis unavailable, so searchStocks falls through to DB query
  - 2-minute TTL (120s) balances freshness vs database load for search results
---

## US-040: Create filing service
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/services/filing.service.ts with four core functions:
  - getLatestFilings({ limit, offset }): Paginated latest filings across all stocks with stock ticker/name via INNER JOIN
  - getFilingsByStock(stockId, { limit, offset, type }): Stock-specific filings with optional type filter
  - getFilingById(filingId, userId): Single filing detail with per-user is_read status via filing_reads join table
  - markAsRead(filingId, userId): Upserts into filing_reads table (idempotent via onConflictDoNothing)
- All functions follow established service pattern: null db check, typed interfaces, Drizzle ORM queries
- Exported TypeScript interfaces: GetFilingsOptions, GetFilingsByStockOptions, FilingWithStock, GetLatestFilingsResult, GetFilingsByStockResult, FilingDetail
- npm run build passes with zero errors
- Files changed: src/services/filing.service.ts (created)
- **Learnings for future iterations:**
  - Drizzle's innerJoin() with eq() condition provides clean SQL JOIN syntax for fetching related data
  - and() from drizzle-orm used for combining WHERE conditions (stockId + type filter, userId + filingId)
  - onConflictDoNothing() enables idempotent upsert for filing_reads (marking as read twice is a no-op)
  - Filing detail pattern: separate queries for filing data and read status, then combine in return object
  - getLatestFilings joins with stocks table to include stock_ticker and stock_name in response
  - getFilingsByStock accepts stockId (UUID) not ticker ‚Äî caller must resolve ticker to stockId first
  - markAsRead verifies filing exists before inserting read record to provide clear 404 error
  - Pagination pattern consistent with stock.service.ts: count query + data query with limit/offset
---

## US-041: Implement GET /v1/filings endpoint
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/routes/filings.routes.ts with GET /filings endpoint
  - Applied authMiddleware to all filing routes via filingRoutes.use('*', authMiddleware)
  - Validates query params with Zod: limit (default 20), offset (default 0)
  - Clamps limit to 1-100 range and offset to 0+ for safety
  - Calls getLatestFilings() from filing.service.ts with parsed options
  - Maps Drizzle camelCase fields to snake_case for API response
  - Includes stock_ticker and stock_name from joined stocks table in each filing response
  - Returns paginated response using paginated() builder from utils/response.ts
- Registered filing routes on main app in src/app.ts via app.route('/filings', filingRoutes)
- npm run build passes with zero errors
- Files changed: src/routes/filings.routes.ts (created), src/app.ts (modified), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - Filing route follows same pattern as stocks.routes.ts: Hono instance with Variables type, auth middleware, Zod query validation
  - getLatestFilings() returns FilingWithStock objects with nested filing + stock_ticker/stock_name, requiring flattening in DTO mapping
  - Filing dates returned as ISO 8601 strings via .toISOString() per API conventions
  - Route registered at /filings prefix, so full path is /v1/filings
  - Filing DTO includes both filing fields and stock context (stock_ticker, stock_name) for client convenience
---

## US-042: Implement GET /v1/filings/:id and POST /v1/filings/:id/read
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Added GET /filings/:id endpoint to src/routes/filings.routes.ts
  - Returns filing detail with per-user is_read status
  - Uses getFilingById(filingId, userId) from filing.service.ts
  - Maps Drizzle camelCase to snake_case for API response
  - Returns 404 NOT_FOUND if filing doesn't exist (handled by service layer)
- Added POST /filings/:id/read endpoint to src/routes/filings.routes.ts
  - Upserts into filing_reads table via markAsRead(filingId, userId) from filing.service.ts
  - Returns { filing_id, is_read: true } on success
  - Returns 404 NOT_FOUND if filing doesn't exist (handled by service layer)
  - Idempotent: marking as read twice is a no-op (onConflictDoNothing in service)
- Imported getFilingById, markAsRead, and success from existing modules
- Both endpoints require auth middleware (applied globally to all filing routes)
- npm run build passes with zero errors
- Files changed: src/routes/filings.routes.ts (modified), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - Service layer (getFilingById, markAsRead) was already fully implemented in US-040, only route handlers needed
  - Filing detail DTO includes is_read but NOT stock_ticker/stock_name (unlike list endpoint) ‚Äî client has filing ID context
  - POST /filings/:id/read returns the filing_id and is_read confirmation rather than full filing object
  - Auth middleware applied via filingRoutes.use('*', authMiddleware) covers all sub-routes including /:id and /:id/read
  - Hono parameterized routes /:id and /:id/read coexist cleanly without conflicts
---

## US-043: Implement GET /v1/stocks/:ticker/filings
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Added GET /stocks/:ticker/filings endpoint to src/routes/stocks.routes.ts
  - Validates query params with Zod: limit (default 20), offset (default 0), type (optional filing type filter)
  - Resolves ticker to stock record via direct DB query, returns 404 if ticker not found
  - Calls getFilingsByStock() from filing.service.ts with stock ID and parsed options
  - Maps Drizzle camelCase fields to snake_case for API response
  - Returns paginated response using paginated() builder
- Route registered BEFORE /:ticker catch-all to avoid /:ticker matching "filings" as a ticker param
- Reused existing getFilingsByStock() from filing.service.ts (implemented in US-040) ‚Äî no service changes needed
- Auth middleware already applied globally to all stock routes
- npm run build passes with zero errors
- Files changed: src/routes/stocks.routes.ts (modified)
- **Learnings for future iterations:**
  - Route ordering in Hono: /:ticker/filings must be defined before /:ticker to match correctly
  - Ticker resolution pattern: direct DB query (eq + toUpperCase) is simpler than calling getStockByTicker() which does extra work (executives, filings, watchlist)
  - getFilingsByStock() accepts stockId (UUID) not ticker ‚Äî need to resolve ticker to stock first
  - Filing type filter is optional ‚Äî when omitted, all filing types are returned
  - Same DTO mapping pattern as filings.routes.ts for consistency
  - No service layer changes needed ‚Äî route-only implementation leveraging existing filing.service.ts
---

## US-044: Create executive service
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/services/executive.service.ts with four functions:
  - getExecutivesForStock(stockId): Returns all executives for a stock, ordered by tenure (desc)
  - searchByName(query, limit): Searches executives by name or title using ILIKE, default limit 10
  - getExecutiveById(id): Returns single executive by UUID, throws NotFoundError if not found
  - getExecutiveScore(stockId): Calculates executive team score (0-100) from three components
- Executive score calculation:
  - Team size: max 30pts (5+ executives = full score, 6pts per executive)
  - Avg tenure: max 40pts (10+ years average = full score, linearly scaled)
  - Specialization diversity: max 30pts (5+ unique specializations = full score, 6pts per unique spec)
- All functions follow established service patterns: null db check, typed interfaces, Drizzle ORM queries
- Exported ExecutiveScore interface for typed score results
- npm run build passes with zero errors
- Files changed: src/services/executive.service.ts (created)
- **Learnings for future iterations:**
  - Executive score calculation uses simple linear scaling capped at maximum (Math.min)
  - Specialization diversity filters out null/empty strings before counting unique values
  - searchByName searches both name AND title fields for flexible executive lookup
  - getExecutivesForStock returns all executives (no pagination) since team sizes are small (3-5 per stock)
  - Set() used for counting unique specializations ‚Äî efficient deduplication
  - Service follows same pattern as stock.service.ts and filing.service.ts
---

## US-045: Implement executive endpoints
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/routes/executives.routes.ts with two endpoints:
  - GET /executives/search?q=&limit= - search executives by name or title using ILIKE
  - GET /executives/:id - get executive detail with full career history
- Added GET /stocks/:ticker/executives to src/routes/stocks.routes.ts
  - Resolves ticker to stock record, returns 404 if ticker not found
  - Returns all executives for the stock via getExecutivesForStock() from executive.service.ts
  - Route placed before /:ticker catch-all to avoid matching "executives" as a ticker
- Registered executive routes on main app in src/app.ts via app.route('/executives', executiveRoutes)
- All endpoints return snake_case JSON DTOs with full executive fields
- Auth middleware applied globally to both executive routes and stock routes
- npm run build passes with zero errors
- Files changed: src/routes/executives.routes.ts (created), src/routes/stocks.routes.ts (modified), src/app.ts (modified)
- **Learnings for future iterations:**
  - Executive routes follow same pattern as filing routes: Hono instance with Variables type, auth middleware
  - Stock-specific executive endpoint (/stocks/:ticker/executives) placed in stocks.routes.ts for URL consistency
  - Route ordering matters: /:ticker/executives must be before /:ticker to match correctly
  - Executive service was fully implemented in US-044, only route handlers needed
  - DTO mapping pattern consistent across all routes: Drizzle camelCase ‚Üí API snake_case
  - No pagination needed for stock executives since team sizes are small (3-5 per stock)
---

## US-046: Create user service for profile and settings
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/services/user.service.ts with four functions:
  - getProfile(userId): Looks up user by ID, throws NotFoundError if not found
  - updateProfile(userId, input): Updates display_name and/or avatar_url, sets updatedAt
  - getSettings(userId): Returns user settings JSONB, creates default settings on first access
  - updateSettings(userId, settings): Merges provided settings into existing settings JSONB
- Default settings created on first access: notifications_enabled, push_alerts, email_alerts, dark_mode, language
- Settings stored as JSONB in user_settings table (one record per user via unique FK)
- All functions follow established service patterns: null db check, typed interfaces, Drizzle ORM queries
- npm run build passes with zero errors
- Files changed: src/services/user.service.ts (created), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - user_settings table has unique constraint on userId, so one settings record per user
  - getSettings() creates default settings on first access (lazy initialization pattern)
  - updateSettings() uses shallow merge ({ ...current, ...new }) for merging settings updates
  - Settings JSONB allows flexible schema-free storage for app preferences
  - UpdateProfileInput uses optional fields so only changed fields are updated
  - Reused users table type inference via $inferSelect for UserProfile type
---

## US-047: Implement user profile and settings endpoints
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/routes/users.routes.ts with four endpoints:
  - GET /users/me - returns current user profile from auth context
  - PUT /users/me - updates display_name and/or avatar_url
  - GET /users/me/settings - returns user settings JSONB
  - PUT /users/me/settings - merges/updates settings JSONB
- Applied authMiddleware globally to all user routes via userRoutes.use('*', authMiddleware)
- Registered user routes on main app in src/app.ts via app.route('/users', userRoutes)
- Zod validation for PUT /users/me: display_name (optional, 1-255 chars), avatar_url (optional, valid URL)
- Zod validation for PUT /users/me/settings: uses z.object({}).passthrough() for flexible JSONB updates
- All responses use snake_case DTOs (display_name, avatar_url, auth_provider, created_at, updated_at)
- npm run build passes with zero errors
- Files changed: src/routes/users.routes.ts (created), src/app.ts (modified)
- **Learnings for future iterations:**
  - User routes follow same pattern as stocks/filings/executives: Hono instance with Variables type, auth middleware
  - c.get('user').id provides authenticated user ID from JWT token for profile lookup
  - PUT /users/me/settings uses z.object({}).passthrough() to accept any JSON keys for flexible JSONB storage
  - User service (US-046) was fully implemented, only route handlers needed
  - DTO mapping pattern consistent across all routes: Drizzle camelCase ‚Üí API snake_case
  - Request body field names use snake_case (display_name) but service layer uses camelCase (displayName) ‚Äî mapping done in route handler
---

## US-048: Implement GET /v1/subscription endpoint
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/routes/subscription.routes.ts with GET /subscription endpoint
  - Applied authMiddleware globally to all subscription routes
  - Returns current user's tier from auth context (JWT payload)
  - Returns tier-specific limits: watchlist, sync_interval_hours, pulse_delay_hours, alert_rules_max
- Tier limits defined as constant map:
  - FREE: 5 watchlist, 24h sync, 12h pulse delay, 50 alert rules max
  - PRO: 25 watchlist, 12h sync, 4h pulse delay, 50 alert rules max
  - PREMIUM: unlimited watchlist (-1), 4h sync, 0h pulse delay (real-time), 50 alert rules max
- Registered subscription routes on main app in src/app.ts via app.route('/subscription', subscriptionRoutes)
- Added 'subscription' tag to OpenAPI documentation configuration
- npm run build and npm run typecheck both pass with zero errors
- Files changed: src/routes/subscription.routes.ts (created), src/app.ts (modified), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - Subscription endpoint is a simple read-only endpoint ‚Äî no service layer needed since tier comes from JWT context
  - Tier limits defined as a static constant map (TIER_LIMITS) since they don't change at runtime
  - user.tier from auth context provides the tier directly from JWT payload without DB lookup
  - Default fallback to 'free' tier limits when tier not found in map (defensive coding)
  - watchlist: -1 convention for "unlimited" ‚Äî clients should interpret negative values as unlimited
  - pulse_delay_hours: 0 means real-time for PREMIUM tier
  - No Zod validation needed since GET endpoint has no request body or query params
  - Route follows same pattern as other route groups: Hono instance with Variables type, auth middleware
---

## US-049: Register all CRUD routes on main app
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/routes/index.ts barrel export for all route groups
  - Exports: healthRoutes, authRoutes, stockRoutes, filingRoutes, executiveRoutes, userRoutes, subscriptionRoutes
- Updated src/app.ts to import all routes from barrel export instead of individual route files
  - Replaced 7 individual imports with single barrel import from './routes/index.js'
  - All 7 route groups remain mounted at their existing paths: /health, /auth, /stocks, /filings, /executives, /users, /subscription
- All routes accessible under /v1/ prefix via app.basePath('/v1')
- npm run build passes with zero errors
- Files changed: src/routes/index.ts (created), src/app.ts (modified), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - Barrel export in routes/index.ts centralizes all route imports for cleaner app.ts
  - As new route groups are added (vetr-score, red-flags, alerts, watchlist, sync), add them to routes/index.ts and app.ts
  - All existing route registrations were already in place from US-037 through US-048 ‚Äî this story consolidates imports
  - OpenAPI tags already defined for all planned route groups (including vetr-score, red-flags, alerts, watchlist, sync)
---

## US-050: Create VETR Score calculation service - component calculators
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/services/vetr-score.service.ts with three component calculator functions
- Implemented pedigreeScore(executives):
  - Experience score (50pts max at 20yr avg): uses yearsAtCompany + estimated previous experience (~3yr per previous company)
  - Tenure stability (30pts max at 10yr avg): based on average yearsAtCompany
  - Specialization (20pts max at 5+ unique): counts unique non-null specializations, 4pts per unique spec
- Implemented filingVelocityScore(filings):
  - Regularity (40pts max at 12+ filings/year): counts filings from last 12 months
  - Timeliness (30pts max): most recent filing 0-7 days = full, 30+ days = 0, linear interpolation between
  - Quality (30pts max): material filing proportion (15pts) + filing type diversity (15pts, 4+ types = full)
- Implemented redFlagComponent(compositeScore): returns 100 - clamped score (0-100)
- Added helper functions getExecutivesForTicker() and getFilingsForTicker() for database lookups by stock ticker
- All functions are pure (except DB helpers) and accept typed inputs, making them independently testable
- npm run build passes with zero errors
- Files changed: src/services/vetr-score.service.ts (created)
- **Learnings for future iterations:**
  - Component calculators are pure functions (no DB calls) ‚Äî accept data arrays and return scores
  - Database lookup helpers separated from scoring logic for clean testability
  - Experience estimation: ~3 years per previous company is a reasonable heuristic for mining industry
  - Filing timeliness uses linear interpolation between 7-day (full) and 30-day (zero) thresholds
  - Quality score combines two sub-components: material filing proportion + type diversity
  - redFlagComponent is a simple inversion: 100 - score, so low red flags = high VETR score
  - Type inference from Drizzle schema: `typeof executives.$inferSelect` provides full type for executive rows
  - All scores are 0-100 range, clamped with Math.min/Math.max as needed
---

## US-051: Implement growth and governance score components
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Added growthMetricsScore(stock) to src/services/vetr-score.service.ts
  - Revenue Growth (40pts max at 50%+ price change): uses priceChange as proxy for revenue growth momentum
  - Capital Raised (30pts max at $100M+ market cap): uses marketCap as proxy for capital-raising ability
  - Momentum (30pts max): combines price direction (15pts) and relative market cap strength (15pts)
- Added governanceScore(executives, filings) to src/services/vetr-score.service.ts
  - Board Independence (40pts max): counts unique executive titles, 8pts per unique title (5+ = full)
  - Audit Committee (30pts max): financial oversight roles (15pts) + audited financials proportion (15pts)
  - Disclosure Quality (30pts max): filing regularity (15pts) + filing type coverage (15pts)
- Added getStockByTicker() helper function for database lookup by ticker (returns full StockRow)
- Added StockRow type alias: `typeof stocks.$inferSelect`
- Each component returns a score 0-100
- npm run build passes with zero errors
- Files changed: src/services/vetr-score.service.ts (modified), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - Stock schema lacks explicit revenue growth, capital raised, debt ratio fields ‚Äî used price_change and market_cap as proxies
  - growthMetricsScore accepts StockRow type (not just ticker) for flexibility and testability
  - governanceScore combines executive data and filing data for a holistic governance assessment
  - Financial role detection uses substring matching on exec titles (includes 'cfo', 'chief financial officer', etc.)
  - Disclosure quality reuses similar logic to filingVelocityScore but with different point allocation
  - getStockByTicker helper is useful for US-052 (full VETR Score calculation) pipeline
  - All component calculators are pure functions (no DB calls) ‚Äî accept data arrays/objects and return scores
  - Math.min capping ensures no sub-component exceeds its allocated points
---

## US-052: Implement full VETR Score calculation with bonuses and caching
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Added calculateVetrScore(ticker) to src/services/vetr-score.service.ts
  - Combines 5 component scores with weights: pedigree (25%), filing_velocity (20%), red_flag (25%), growth (15%), governance (15%)
  - Fetches stock, executives, and filings data (executives + filings fetched in parallel via Promise.all)
  - Calculates all component scores using existing pure functions from US-050 and US-051
  - Red flag composite defaults to 0 (will be provided by red-flag.service.ts in US-055+)
- Added detectBonuses() function:
  - +5 for audited financials (has "Financial Statements" filing type)
  - +5 for board expertise (executives with P.Eng, P.Geo, CPA, CFA, MBA, PhD, FCA in education)
- Added detectPenalties() function:
  - -10 for overdue filings (no filings in last 90 days when filings exist)
  - -10 for regulatory issues (material press releases mentioning regulatory/compliance/sanction/violation)
- Final score clamped to 0-100 via Math.max(0, Math.min(100, ...))
- Redis caching with 24h TTL (key: vetr_score:{TICKER})
  - Cache check on entry, cache set after calculation
  - Gracefully degrades when Redis unavailable (cache.get returns null)
- Saves to vetr_score_history table via saveScoreToHistory() helper
  - Uses Drizzle insert into vetrScoreHistory table
  - Wrapped in try/catch to not fail the calculation if history save fails
- Exported VetrScoreResult interface with full score breakdown
- npm run build and npm run typecheck both pass with zero errors
- Files changed: src/services/vetr-score.service.ts (modified)
- **Learnings for future iterations:**
  - Cache-first pattern: check cache ‚Üí calculate if miss ‚Üí cache result ‚Üí return
  - Promise.all for parallel DB queries (executives + filings) improves performance
  - Bonus/penalty detection uses filing content analysis (type, title keywords)
  - saveScoreToHistory uses try/catch so DB errors don't break the score calculation flow
  - Red flag composite is hardcoded to 0 until red-flag.service.ts is implemented in US-055+
  - VetrScoreResult uses snake_case for all fields (matching API response conventions)
  - WEIGHTS defined as const object for easy reference and modification
  - Cache key pattern: vetr_score:{TICKER} with 24h TTL (86400 seconds)
---

## US-053: Implement VETR Score API endpoints
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/routes/vetr-score.routes.ts with two endpoints:
  - GET /stocks/:ticker/vetr-score - returns current score with full component breakdowns (cached or freshly calculated)
  - GET /stocks/:ticker/vetr-score/history?months=6 - returns historical score data from vetr_score_history table
- Added getScoreHistory() function to src/services/vetr-score.service.ts
  - Queries vetr_score_history table filtered by ticker and date range (configurable months parameter, default 6)
  - Uses and(), eq(), gte() from drizzle-orm for compound WHERE conditions
  - Returns ScoreHistoryEntry[] with all component scores in snake_case format
  - Ordered by calculated_at descending (most recent first)
- Applied authMiddleware globally to all vetr-score routes
- Registered vetrScoreRoutes on main app via app.route('/stocks', vetrScoreRoutes) ‚Äî mounted under /stocks prefix so full paths are /v1/stocks/:ticker/vetr-score and /v1/stocks/:ticker/vetr-score/history
- Updated src/routes/index.ts barrel export with vetrScoreRoutes
- History endpoint validates months query param (clamped to 1-24 range)
- Current score endpoint uses calculateVetrScore() which returns cached result if available (24h Redis TTL)
- npm run build passes with zero errors
- Files changed: src/routes/vetr-score.routes.ts (created), src/services/vetr-score.service.ts (modified), src/routes/index.ts (modified), src/app.ts (modified)
- **Learnings for future iterations:**
  - Multiple Hono route groups can be mounted at the same path prefix (app.route('/stocks', stockRoutes) AND app.route('/stocks', vetrScoreRoutes)) ‚Äî Hono merges them correctly
  - History route must be registered BEFORE the parameterized parent route (/:ticker/vetr-score/history before /:ticker/vetr-score) to match correctly
  - gte() from drizzle-orm provides >= comparison for date range filtering
  - and() combines multiple WHERE conditions into a single clause
  - ScoreHistoryEntry interface uses snake_case fields matching API conventions
  - Months parameter clamped to 1-24 range for reasonable history queries
  - getScoreHistory returns empty array (not error) for tickers with no history yet
---

## US-054: Implement VETR Score trend and comparison endpoints
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Added getScoreTrend(ticker) to src/services/vetr-score.service.ts
  - Fetches last 90 days of score history from vetr_score_history table
  - Calculates trend_direction: improving (>+5 over 90d), declining (<-5 over 90d), or stable
  - Calculates momentum: -100 to +100 using weighted average of 30d (60%) and 90d (40%) changes
  - Returns change_30d and change_90d absolute score changes
  - Returns data_points count for transparency
  - Handles insufficient data gracefully (returns stable/0 for <=1 data points)
- Added getScoreComparison(ticker) to src/services/vetr-score.service.ts
  - Fetches all stocks in the same sector as the target stock
  - Calculates percentile_rank (0-100) based on position among sector peers
  - Returns up to 10 peer scores (excluding the target stock) sorted by score descending
  - Returns sector statistics: sector_average, sector_high, sector_low
  - Uses vetr_score from stocks table for peers, calculates fresh score for target stock
- Added two new route handlers in src/routes/vetr-score.routes.ts:
  - GET /:ticker/vetr-score/trend - returns ScoreTrendResult
  - GET /:ticker/vetr-score/compare - returns ScoreComparisonResult
  - Both routes placed before the main /:ticker/vetr-score route to avoid path conflicts
- Routes already registered on main app via app.route('/stocks', vetrScoreRoutes) ‚Äî no app.ts changes needed
- Exported ScoreTrendResult, PeerScore, ScoreComparisonResult interfaces
- npm run build passes with zero errors
- Files changed: src/services/vetr-score.service.ts (modified), src/routes/vetr-score.routes.ts (modified), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - Trend analysis requires historical data points ‚Äî graceful degradation needed when history is sparse
  - Momentum calculation uses weighted average: 30d change (60% weight) + 90d change (40% weight), then scaled by 2x and clamped to -100..+100
  - Percentile rank formula: ((peer_count - rank) / (peer_count - 1)) * 100 ‚Äî handles single stock edge case
  - Sector peer comparison uses stocks.vetrScore (stored) for peers rather than calculating fresh scores for every peer (performance)
  - Route ordering: /trend and /compare must be defined before the parent /:ticker/vetr-score catch-all
  - No changes needed to app.ts or routes/index.ts since vetrScoreRoutes was already mounted at /stocks prefix
---

## US-055: Create Red Flag detection service - consolidation and financing velocity
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/services/red-flag.service.ts with two detector functions
- Implemented detectConsolidationVelocity(stockTicker): scans last 12 months of filings for acquisition/merger/consolidation keywords, scores 1‚Üí20pts, 2‚Üí40pts, 3‚Üí60pts, 4‚Üí80pts, 5+‚Üí100pts, weight 30%
- Implemented detectFinancingVelocity(stockTicker): scans last 12 months of filings for financing keywords (private placement, prospectus, offering, etc.), early-stage threshold 3 events ($50M equiv), growth-stage threshold 5 events ($100M equiv), weight 25%
- Added RedFlagDetail and DetectedFlagResult interfaces for typed results
- Added internal helper functions getStockByTicker, getFilingsForTicker, getExecutivesForTicker (separate from vetr-score.service.ts to avoid circular deps)
- npm run build passes with zero errors
- Files changed: src/services/red-flag.service.ts (created), scripts/ralph/prd.json (modified)
- **Learnings for future iterations:**
  - Red flag detection relies on keyword matching against filing titles and summaries since the DB doesn't store explicit acquisition/financing event records
  - Consolidation velocity uses a discrete step function (20pts per event) while financing velocity uses a continuous linear scale
  - Early-stage vs growth-stage classification based on $500M market cap threshold
  - Helper functions are duplicated from vetr-score.service.ts ‚Äî could be refactored into a shared module in future if needed
  - The service is designed for extensibility ‚Äî US-056 will add executive churn, disclosure gaps, and debt trend detectors, US-057 will add composite scoring
---

## US-056: Implement executive churn, disclosure gaps, debt trend detectors
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Added three remaining Red Flag detectors to src/services/red-flag.service.ts
- Implemented detectExecutiveChurn(stockTicker):
  - Measures executive turnover by counting executives with <1 year tenure (yearsAtCompany < 1)
  - Scoring: 1‚Üí25pts, 2‚Üí50pts, 3‚Üí75pts, 4+‚Üí100pts
  - Weight: 20%
  - Uses existing getExecutivesForTicker() helper
- Implemented detectDisclosureGaps(stockTicker):
  - Measures gap between most recent filing date and current date
  - Scoring: overdue (120+ days)‚Üí100pts, 90+d‚Üí75pts, 60-89d‚Üí50pts, 30-59d‚Üí25pts, <30d‚Üí0pts
  - No filings at all treated as overdue (100pts)
  - Uses existing getFilingsForTicker() helper (ordered by date DESC, so [0] is most recent)
  - Weight: 15%
- Implemented detectDebtTrend(stockTicker):
  - Analyzes filing content for debt-related vs revenue-positive keywords
  - Debt keywords: debenture, credit facility, loan, debt, restructuring, default, covenant, etc.
  - Revenue keywords: revenue growth, earnings growth, profit, positive cash flow, etc.
  - Uses ratio of debt filings to total filings as the scoring input
  - High debt ratio (50%+) with low revenue signals (<20%) ‚Üí 100pts, 37.5%+‚Üí75pts, 25%+‚Üí50pts, 12.5%+‚Üí25pts
  - Weight: 10%
- npm run build passes with zero errors
- Files changed: src/services/red-flag.service.ts (modified)
- **Learnings for future iterations:**
  - Executive churn detector leverages yearsAtCompany field directly ‚Äî executives with <1 year tenure are considered recent hires replacing departed executives
  - Disclosure gaps detector relies on filing list being ordered by date DESC (from getFilingsForTicker helper)
  - Debt trend uses filing content analysis (keyword matching) as proxy since stock schema lacks explicit debt/revenue ratio fields
  - All three detectors follow the same pattern as consolidation and financing velocity: return RedFlagDetail with flag_type, score, weight, weighted_score, description
  - The 5 weights sum to 100%: consolidation (30%) + financing (25%) + churn (20%) + disclosure (15%) + debt (10%)
  - US-057 will combine all 5 detectors into a composite red flag scoring function
---

## US-057: Implement composite red flag scoring with caching
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Added `detectRedFlags(ticker)` function to src/services/red-flag.service.ts
  - Runs all 5 detectors in parallel (consolidation velocity, financing velocity, executive churn, disclosure gaps, debt trend)
  - Calculates weighted composite score as sum of (score √ó weight) for each detector
  - Classifies severity: Low (<30), Moderate (30-60), High (60-85), Critical (>85)
  - Returns DetectedFlagResult with composite score, severity, and per-flag breakdown
- Added Redis caching with 24h TTL (key: `red_flags:{TICKER}`)
  - Checks cache first, returns cached result if available
  - Caches fresh result after calculation
- Added `saveRedFlagsToHistory()` to persist individual flags to red_flag_history table
  - Each flag saved with its own severity classification (per-flag, not overall)
  - Graceful error handling: logs failure but doesn't fail the detection
- Added `classifySeverity()` helper for severity classification
- Added imports: `redFlagHistory` from schema, `cache` service
- NotFoundError now used when stock ticker doesn't exist (was imported but unused before)
- npm run build passes with zero errors
- Files changed: src/services/red-flag.service.ts (modified)
- **Learnings for future iterations:**
  - Promise.all() for running detectors in parallel significantly improves performance
  - Cache key pattern `red_flags:{TICKER}` consistent with vetr_score cache pattern
  - Per-flag severity classification differs from overall composite severity
  - saveRedFlagsToHistory uses try/catch to avoid failing the main operation on DB errors
  - redFlagHistory table uses individual flag severity, not the composite severity
---

## US-058: Implement Red Flag API endpoints
Status: ‚úÖ COMPLETE
Date: 2026-02-08
Details:
- Created src/routes/red-flags.routes.ts with two route groups:
  - redFlagStockRoutes (mounted at /stocks): handles /stocks/:ticker/red-flags and /stocks/:ticker/red-flags/history
  - redFlagGlobalRoutes (mounted at /red-flags): handles /red-flags/history
- GET /stocks/:ticker/red-flags - calls detectRedFlags(ticker), returns composite score with per-flag breakdown
- GET /stocks/:ticker/red-flags/history - paginated flag history for a specific stock from red_flag_history table
- GET /red-flags/history?limit=20 - global paginated flag history across all stocks
- Added getRedFlagHistoryForStock() and getGlobalRedFlagHistory() to src/services/red-flag.service.ts
  - Both use parallel count + data queries with Promise.all for performance
  - Stock-specific history validates stock exists first (throws NotFoundError)
  - Both return proper PaginationMeta with total, limit, offset, has_more
- All endpoints use auth middleware, Zod query validation, and snake_case response format
- Updated src/routes/index.ts to export redFlagStockRoutes and redFlagGlobalRoutes
- Updated src/app.ts to mount both route groups
- npm run build passes with zero errors
- Files changed: src/services/red-flag.service.ts, src/routes/red-flags.routes.ts (new), src/routes/index.ts, src/app.ts
- **Learnings for future iterations:**
  - When routes need multiple mount points (e.g., /stocks/:ticker/red-flags AND /red-flags/history), use two separate Hono route groups
  - Both groups are exported from the same file and mounted at different prefixes in app.ts
  - History routes place the more specific path (/history) before the catch-all to avoid route conflicts
  - Drizzle's sql`count(*)::int` template literal is used for typed count queries
  - PaginationMeta type imported from types/pagination.ts for consistent pagination response shape
---
